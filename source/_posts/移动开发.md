title: 移动开发
date: 2016-03-08 18:15:19
tags: "移动端web开发"
categories: "移动端web开发"
---
记录自己在移动端web开发中遇到的问题。

### iscroll5 的上拉加载，下拉刷新
iscroll4之前有这个功能，但是在iscroll5里面被移除了，
github上，我写了一个针对iscroll5实现上拉加载，下拉刷新功能的demo [isrcoll5-fresh-demo](https://github.com/yangmingkun187/isrcoll5-fresh-demo.git)

### flex布局问题
* 使用块级元素作为flex元素的子元素；
Android Browser4.3及以下，iOS Safari6.1及以下 的 flex子项 需要使用块级元素，在这些版本之上还可以使用行内块元素
在这些版本中，如果你发现flex子项之间出现了间隙，或者在未定义换行的情况下子项自身抑或子项之间换行了，或者出现了其它不正常的情况，那么仔细看一下flex子项可能是使用了行内级元素；
* 当横向布局时，给flex元素的子元素定义width为非auto的值，当纵向布局时，给flex元素的子元素定义height为非auto的值；
Android Browser4.3及以下，iOS Safari6.1及以下的flex元素的子元素如果没有显式的定义height或width为非auto的值，那么子元素分配父元素剩余空间时将会不符合标准预期；

### UC浏览器下使用rem的问题
最近将微站转向wap版，之前微站端使用rem，但是在安卓手机UC浏览器上rem好像没有起作用。网上的说法是要让页面进行重绘，但是试过那些建议的办法，并没有卵用，
[点击查看页面重绘的方法](http://www.css88.com/archives/4996)
解决办法：
之前写过使用rem解决不同屏幕大小的字号显示，只需要在里面多加一段代码
``` javascript
(function (doc, win) {
  var docEl = doc.documentElement,
    resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    recalc = function () {
      var clientWidth = docEl.clientWidth;
      if (!clientWidth) return;
      // 针对uc横竖屏rem html没有重绘的问题
      var style;
      if(style=document.getElementById("hackUCRem")){
         style.parentNode.removeChild(style);
      }
      style = document.createElement("style");
      style.id="hackUCRem";
      document.head.appendChild(style);
      // 在head中加入一个style标签，插入属性 html{font-size: 22px !important;}
      style.appendChild(document.createTextNode("html{font-size:"+20 * (clientWidth / 320)+"px !important;}"));
      // 常规写法
      docEl.style.fontSize = 20 * (clientWidth / 320) + 'px';
    };
  recalc();
  if (!doc.addEventListener) return;
  win.addEventListener(resizeEvt, recalc, false);
  doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);
```
<!-- more -->

### 安卓css画圆的问题
用CSS画一个圆很简单，只需要一句代码：
``` css
.circle {
    border-radius: 50%;
}
```
但是Android Browser2.0 不支持以百分比作为 <code>border-radius</code> 的值，所以会显示为默认的矩形。
解决办法(给定数值)：
``` css
.circle {
    width: 10rem;
    height: 10rem;
    border-radius: 5rem;
}
```

### 使用rem解决不同屏幕大小的字号显示
``` javascript
(function (doc, win) {
  var docEl = doc.documentElement,
    resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize',
    recalc = function () {
      var clientWidth = docEl.clientWidth;
      if (!clientWidth) return;
      docEl.style.fontSize = 20 * (clientWidth / 320) + 'px';
    };

  if (!doc.addEventListener) return;
  win.addEventListener(resizeEvt, recalc, false);
  doc.addEventListener('DOMContentLoaded', recalc, false);
})(document, window);
```

### 同屏切换的问题
使用transform实现同屏切换后，在当前屏点击后退键，我们期望的是回到前一屏，但是实际上会回到前一个页面。因为同屏切换url并没有变，只是页面上的可视区域变了。
解决办法：
在切屏操作的时候，执行下面：
``` javascript
if(history.pushState){
    history.pushState('status','',location.href.split('?')[0]+'?status');
}
```
然后监听popstate：
``` javascript
if(history.pushState){
    window.addEventListener('popstate',function(){
        // 点击后退键执行的操作
    })
}
```
![Alt text](http://gtms01.alicdn.com/tps/i1/T1N9rZFdddXXbZIE3X-1200-900.png)

### 移动端点击事件
移动端click事件延迟300ms

这要追溯至 2007 年初。苹果公司在发布首款 iPhone 前夕，遇到一个问题：当时的网站都是为大屏幕设备所设计的。于是苹果的工程师们做了一些约定，应对 iPhone 这种小屏幕浏览桌面端站点的问题。

这当中最出名的，当属双击缩放(double tap to zoom)，这也是会有上述 300 毫秒延迟的主要原因。双击缩放，顾名思义，即用手指在屏幕上快速点击两次，iOS 自带的 Safari 浏览器会将网页缩放至原始比例。

那么这和 300 毫秒延迟有什么联系呢？

假定这么一个场景。用户在 iOS Safari 里边点击了一个链接。由于用户可以进行双击缩放或者双击滚动的操作，当用户一次点击屏幕之后，浏览器并不能立刻判断用户是确实要打开这个链接，还是想要进行双击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。

鉴于iPhone的成功，其他移动浏览器都复制了 iPhone Safari 浏览器的多数约定，包括双击缩放，几乎现在所有的移动端浏览器都有这个功能。之前人们刚刚接触移动端的页面，在欣喜的时候往往不会care这个300ms的延时问题，可是如今touch端界面如雨后春笋，用户对体验的要求也更高，这300ms带来的卡顿慢慢变得让人难以接受。
[参考文章](http://www.xiaomeiti.com/note/3585)
##### 解决办法：
1. 直接使用 fastclick
优点：全局引入，方便省事
缺点：增加插件冗余

2. 使用 zepto touch
优点：基于 zepto 核心，还提供 singleTap, doubleTap, longTap, swipe 等简单触控类型判断。
缺点：坑多，例如使用 setTimeout 延迟触发事件，需要解决点透问题。
``` javascript
$(".close-btn").on("tap", function (event) {
   setTimeout(function(){
     alert('点我了');
   },301);
});  
```
3. 直接原生绑定 touchstart / touchend
优点：除了减少插件依赖，好像没想到什么优点。
缺点：需要处理 touchmove scroll 的一些误杀。也不一定就解决快，原生往往预示着需要自己处理一大堆东西。
``` javascript
$(".close-btn").on("touchend", function (event) {
   event.preventDefault();
   alert('点我了');
});  
```
4. 还有 Android 上 Chrome 会根据 viewport 设置 user-scalable=no 禁用双击等等。
